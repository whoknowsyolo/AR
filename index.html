<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fire Emergency AR Game - 3D Version</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ar.js/3.3.0/AR.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            touch-action: none;
            font-family: Arial, sans-serif;
        }
        
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background-color: #000;
            overflow: hidden;
        }
        
        #camera-view {
            position: absolute;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 1;
        }
        
        #three-canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 2;
            pointer-events: none;
        }
        
        #level-indicator {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 24px;
            font-weight: bold;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 10px;
            z-index: 10;
        }
        
        #score-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 24px;
            font-weight: bold;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 10px;
            z-index: 10;
        }
        
        #lives-container {
            position: absolute;
            top: 70px;
            left: 20px;
            display: flex;
            gap: 5px;
            z-index: 10;
        }
        
        .life-icon {
            width: 30px;
            height: 30px;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23ff4500"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>');
            background-size: contain;
        }
        
        #feedback {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 36px;
            font-weight: bold;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 15px;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
            z-index: 10;
        }
        
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        #start-screen h1 {
            color: white;
            font-size: 36px;
            text-align: center;
            margin-bottom: 30px;
        }
        
        #start-button {
            padding: 15px 30px;
            font-size: 24px;
            background-color: #ff4500;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
        }
        
        #start-button:hover {
            background-color: #ff6a33;
        }
        
        #game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        #game-over h1 {
            color: white;
            font-size: 36px;
            margin-bottom: 20px;
        }
        
        #final-score {
            color: white;
            font-size: 48px;
            margin-bottom: 30px;
        }
        
        #restart-button {
            padding: 15px 30px;
            font-size: 24px;
            background-color: #ff4500;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
        }
        
        #restart-button:hover {
            background-color: #ff6a33;
        }
        
        #info-button {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 200;
        }
        
        #info-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-width: 600px;
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px;
            border-radius: 15px;
            z-index: 200;
            display: none;
        }
        
        #info-panel h2 {
            text-align: center;
            margin-bottom: 20px;
        }
        
        .info-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        
        .info-item {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .info-icon {
            width: 40px;
            height: 40px;
            margin-right: 10px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #close-info {
            display: block;
            margin: 20px auto 0;
            padding: 10px 20px;
            background-color: #ff4500;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        
        /* New styles for 3D selection */
        #extinguisher-selector {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 15px;
            padding: 10px;
            z-index: 100;
        }
        
        .extinguisher-btn {
            padding: 10px 15px;
            border-radius: 20px;
            border: 2px solid white;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s, background-color 0.2s;
        }
        
        .extinguisher-btn:active {
            transform: scale(0.95);
        }
        
        #water-btn {
            background-color: #ff0000;
        }
        
        #foam-btn {
            background-color: #0000ff;
        }
        
        #powder-btn {
            background-color: #ffff00;
            color: black;
        }
        
        #co2-btn {
            background-color: #333;
        }
        
        #use-extinguisher-btn {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            padding: 15px 30px;
            font-size: 18px;
            background-color: #ff4500;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            z-index: 100;
            display: none;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <video id="camera-view" autoplay></video>
        <canvas id="three-canvas"></canvas>
        
        <div id="level-indicator">Level: 1</div>
        <div id="score-indicator">Score: 0</div>
        <div id="lives-container"></div>
        
        <div id="feedback">Perfect!</div>
        
        <button id="info-button">i</button>
        <div id="info-panel">
            <h2>Fire Type Guide</h2>
            <div class="info-grid">
                <div class="info-item">
                    <div class="info-icon electrical-fire"></div>
                    <div>Electrical Fire: CO2 (Black)</div>
                </div>
                <div class="info-item">
                    <div class="info-icon gas-fire"></div>
                    <div>Gas Fire: Powder (Yellow)</div>
                </div>
                <div class="info-item">
                    <div class="info-icon wood-fire"></div>
                    <div>Wood Fire: Water (Red)</div>
                </div>
                <div class="info-item">
                    <div class="info-icon liquid-fire"></div>
                    <div>Liquid Fire: Foam (Blue)</div>
                </div>
                <div class="info-item">
                    <div class="info-icon metal-fire"></div>
                    <div>Metal Fire: Powder (Yellow)</div>
                </div>
            </div>
            <button id="close-info">Close</button>
        </div>
        
        <div id="extinguisher-selector">
            <button id="water-btn" class="extinguisher-btn" data-type="water">Water</button>
            <button id="foam-btn" class="extinguisher-btn" data-type="foam">Foam</button>
            <button id="powder-btn" class="extinguisher-btn" data-type="powder">Powder</button>
            <button id="co2-btn" class="extinguisher-btn" data-type="co2">CO2</button>
        </div>
        
        <button id="use-extinguisher-btn">Use Extinguisher</button>
        
        <div id="start-screen">
            <h1>Fire Emergency<br>AR Training</h1>
            <button id="start-button">Start Training</button>
        </div>
        
        <div id="game-over">
            <h1>Training Complete</h1>
            <div id="final-score">Score: 0</div>
            <button id="restart-button">Train Again</button>
        </div>
    </div>

    <script>
        // Game variables
        let currentLevel = 1;
        let score = 0;
        let lives = 3;
        let gameActive = false;
        let activeFire = null;
        let selectedExtinguisher = null;

        // Ground detection variables
let raycaster;
let groundDetected = false;
let groundPosition = new THREE.Vector3();
let groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0)); // Ground is XZ plane
        
        // 3D variables
        let scene, camera, renderer;
        let fireModels = {};
        let extinguisherModel = null;
        let mixer = null;
        let clock = new THREE.Clock();
        
        // DOM elements
        const gameContainer = document.getElementById('game-container');
        const cameraView = document.getElementById('camera-view');
        const threeCanvas = document.getElementById('three-canvas');
        const levelIndicator = document.getElementById('level-indicator');
        const scoreIndicator = document.getElementById('score-indicator');
        const livesContainer = document.getElementById('lives-container');
        const feedback = document.getElementById('feedback');
        const startScreen = document.getElementById('start-screen');
        const startButton = document.getElementById('start-button');
        const gameOverScreen = document.getElementById('game-over');
        const finalScore = document.getElementById('final-score');
        const restartButton = document.getElementById('restart-button');
        const infoButton = document.getElementById('info-button');
        const infoPanel = document.getElementById('info-panel');
        const closeInfoButton = document.getElementById('close-info');
        const useExtinguisherBtn = document.getElementById('use-extinguisher-btn');
        
        // Fire types and their correct extinguishers
        const fireTypes = [
            { type: 'electrical', correctExtinguisher: 'co2' },
            { type: 'gas', correctExtinguisher: 'powder' },
            { type: 'wood', correctExtinguisher: 'water' },
            { type: 'liquid', correctExtinguisher: 'foam' },
            { type: 'metal', correctExtinguisher: 'powder' }
        ];
        
        // Extinguisher colors
        const extinguisherColors = {
            'water': 0xff0000,
            'foam': 0x0000ff,
            'powder': 0xffff00,
            'co2': 0x333333
        };
        
        // Positive feedback messages
        const positiveFeedback = [
            'Perfect!',
            'Great job!',
            'Excellent!',
            'Well done!',
            'Amazing!',
            'Fire out!',
            'Safety pro!'
        ];
        
        // Negative feedback messages
        const negativeFeedback = [
            'Wrong extinguisher!',
            'Try again!',
            'Not effective!',
            'Incorrect choice!',
            'Check your guide!'
        ];
        
        // Initialize Three.js scene
       // Initialize Three.js scene
function initThreeJS() {
    // Create scene
    scene = new THREE.Scene();
    
    // Create camera
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 5;
    
    // Create renderer
    renderer = new THREE.WebGLRenderer({ 
        canvas: threeCanvas,
        alpha: true,
        antialias: true
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000, 0);
    renderer.shadowMap.enabled = true;
    
    // Initialize raycaster for ground detection
    raycaster = new THREE.Raycaster();
    
    // Add lights
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(1, 1, 1);
    directionalLight.castShadow = true;
    scene.add(directionalLight);
    
    // Create a plane for shadow receiving (invisible)
    const shadowPlane = new THREE.Mesh(
        new THREE.PlaneGeometry(20, 20),
        new THREE.ShadowMaterial({ opacity: 0.5 })
    );
    shadowPlane.rotation.x = -Math.PI / 2;
    shadowPlane.position.y = -0.01;
    shadowPlane.receiveShadow = true;
    scene.add(shadowPlane);
    
    // Start animation loop
    animate();
    
    // Handle resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    // Detect ground on app start
    setTimeout(detectGround, 1000);
}

// AR hit test controller
let hitTestSource = null;
let hitTestSourceRequested = false;
let reticle;

// Initialize AR session
function initARSession() {
    const session = renderer.xr.getSession();
    
    // Create reticle (visual indicator for detected ground)
    reticle = new THREE.Mesh(
        new THREE.RingGeometry(0.15, 0.2, 32),
        new THREE.MeshBasicMaterial({ color: 0xffffff })
    );
    reticle.rotation.x = -Math.PI / 2;
    reticle.matrixAutoUpdate = false;
    reticle.visible = false;
    scene.add(reticle);
    
    // Set up hit testing
    session.requestReferenceSpace('viewer').then(function (referenceSpace) {
        session.requestHitTestSource({ space: referenceSpace }).then(function (source) {
            hitTestSource = source;
        });
    });
    
    session.addEventListener('end', function () {
        hitTestSourceRequested = false;
        hitTestSource = null;
    });
    
    hitTestSourceRequested = true;
}

// Detect ground using raycasting
function detectGround() {
    if (!raycaster) return false;
    
    // Cast ray from camera down to detect ground
    raycaster.set(
        new THREE.Vector3(0, 2, 0), 
        new THREE.Vector3(0, -1, 0).normalize()
    );
    
    const intersects = raycaster.intersectObjects(scene.children, true);
    
    if (intersects.length > 0) {
        // Get the first intersection point
        const intersect = intersects[0];
        groundPosition.copy(intersect.point);
        groundDetected = true;
        return true;
    }
    
    // If we're using AR and no real objects detected, use a plane at y=0
    groundPosition.set(
        (Math.random() - 0.5) * 5,  // Random X position
        0,                          // Ground level
        -2 - Math.random() * 3      // Random Z position
    );
    groundDetected = true;
    
    return true;
}
// Update the animation loop to include hit testing
// Animation loop
function animate() {
    requestAnimationFrame(animate);
    
    // Check for ground detection if not already found
    if (!groundDetected) {
        detectGround();
    }
    
    // Update animation mixer if exists
    if (mixer) {
        mixer.update(clock.getDelta());
    }
    
    renderer.render(scene, camera);
}
        
        // Load 3D models
        function loadModels() {
            // For this example, we'll create simple shapes instead of loading real models
            // In a real application, you would use THREE.GLTFLoader to load models
            
            // Create fire models
            fireModels = {
                'electrical': createFireModel(0x66ccff), // Blue electrical fire
                'gas': createFireModel(0xff9900),        // Orange gas fire
                'wood': createFireModel(0xff3300),       // Red wood fire
                'liquid': createFireModel(0x9900ff),     // Purple liquid fire
                'metal': createFireModel(0xffffff)       // White metal fire
            };
            
            // Create extinguisher model base (will be colored based on selection)
            extinguisherModel = createExtinguisherModel();
        }
        
        // Create a simple fire model
        function createFireModel(color) {
    const group = new THREE.Group();
    
    // Number of fire particles
    const particleCount = 200;
    const particles = new THREE.BufferGeometry();
    
    // Positions array (3 values per vertex)
    const positions = new Float32Array(particleCount * 3);
    const colors = new Float32Array(particleCount * 3);
    const sizes = new Float32Array(particleCount);
    
    // Color object for conversion
    const colorObj = new THREE.Color(color);
    
    // Create positions for each particle
    for (let i = 0; i < particleCount; i++) {
        const i3 = i * 3;
        
        // Random position in a cone shape
        const radius = Math.random() * 0.5;
        const angle = Math.random() * Math.PI * 2;
        const height = Math.random() * 1.5;
        
        positions[i3] = Math.cos(angle) * radius;
        positions[i3 + 1] = height;
        positions[i3 + 2] = Math.sin(angle) * radius;
        
        // Color gradient (more yellow/white at top)
        const mixRatio = height / 1.5;
        const fireColor = new THREE.Color(color);
        fireColor.lerp(new THREE.Color(0xffff80), mixRatio);
        
        colors[i3] = fireColor.r;
        colors[i3 + 1] = fireColor.g;
        colors[i3 + 2] = fireColor.b;
        
        // Bigger particles at the bottom
        sizes[i] = 0.1 + (1 - height / 1.5) * 0.2;
    }
    
    // Add attributes to buffer geometry
    particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    particles.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
    
    // Create shader material for fire particles
    const particleMaterial = new THREE.ShaderMaterial({
        uniforms: {
            time: { value: 0.0 },
            pointTexture: { 
                value: new THREE.TextureLoader().load('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAAsTAAALEwEAmpwYAAAFFmlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDIgNzkuMTYwOTI0LCAyMDE3LzA3LzEzLTAxOjA2OjM5ICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpIiB4bXA6Q3JlYXRlRGF0ZT0iMjAyMC0wMy0yM1QxNDo0MDowNyswMTowMCIgeG1wOk1vZGlmeURhdGU9IjIwMjAtMDMtMjNUMTQ6NDM6MTUrMDE6MDAiIHhtcDpNZXRhZGF0YURhdGU9IjIwMjAtMDMtMjNUMTQ6NDM6MTUrMDE6MDAiIGRjOmZvcm1hdD0iaW1hZ2UvcG5nIiBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIiBwaG90b3Nob3A6SUNDUHJvZmlsZT0ic1JHQiBJRUM2MTk2Ni0yLjEiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MzI0M2RjODQtYmRkOS0zMzRk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')
            }
        },
        vertexShader: `
            attribute float size;
            attribute vec3 color;
            varying vec3 vColor;
            uniform float time;
            
            void main() {
                vColor = color;
                
                // Animate the fire
                vec3 pos = position;
                pos.x += sin(time * 2.0 + position.y * 4.0) * 0.1 * (1.0 - position.y);
                pos.z += cos(time * 3.0 + position.y * 5.0) * 0.1 * (1.0 - position.y);
                pos.y += sin(time * 5.0 + position.x * position.z) * 0.05;
                
                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_PointSize = size * (300.0 / -mvPosition.z);
                gl_Position = projectionMatrix * mvPosition;
            }
        `,
        fragmentShader: `
            uniform sampler2D pointTexture;
            varying vec3 vColor;
            
            void main() {
                gl_FragColor = vec4(vColor, 1.0) * texture2D(pointTexture, gl_PointCoord);
                
                // Add glow effect
                float intensity = pow(0.6 - length(gl_PointCoord - vec2(0.5)), 1.5);
                gl_FragColor += vec4(vColor * intensity * 0.5, 0);
            }
        `,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        vertexColors: true
    });
    
    const fireParticles = new THREE.Points(particles, particleMaterial);
    group.add(fireParticles);
    
    // Add embers (small bright particles that rise)
    const emberCount = 30;
    const emberGroup = new THREE.Group();
    group.add(emberGroup);
    
    // Create and animate embers
    for (let i = 0; i < emberCount; i++) {
        createEmber(emberGroup, color);
    }
    
    // Add smoke
    const smokeCount = 20;
    const smokeGroup = new THREE.Group();
    group.add(smokeGroup);
    
    // Create and animate smoke particles
    for (let i = 0; i < smokeCount; i++) {
        createSmoke(smokeGroup);
    }
    
    // Update animation
    function updateFire() {
        if (!group.visible) return;
        
        // Update fire shader time uniform
        particleMaterial.uniforms.time.value += 0.01;
        
        requestAnimationFrame(updateFire);
    }
    
    updateFire();
    
    // Hide initially
    group.visible = false;
    scene.add(group);
    
    return group;
}

// Add appropriate fuel source based on fire type
function addFuelSource(group, color) {
    const fireType = Object.keys(fireModels).find(key => 
        fireModels[key] === group || 
        (fireModels[key] && fireModels[key].uuid === group.uuid)
    );
    
    if (!fireType) return;
    
    let sourceGeometry, sourceMaterial;
    
    switch (fireType) {
        case 'electrical':
            // Electrical panel or device
            sourceGeometry = new THREE.BoxGeometry(0.8, 0.4, 0.6);
            sourceMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
            break;
        case 'gas':
            // Gas canister
            sourceGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.8, 16);
            sourceMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
            break;
        case 'wood':
            // Logs in a pile
            sourceGeometry = new THREE.CylinderGeometry(0.2, 0.2, 1, 8);
            sourceMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
            break;
        case 'liquid':
            // Puddle/container with liquid
            sourceGeometry = new THREE.CylinderGeometry(0.6, 0.5, 0.3, 16);
            sourceMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x3333FF,
                transparent: true,
                opacity: 0.7
            });
            break;
        case 'metal':
            // Metal piece
            sourceGeometry = new THREE.BoxGeometry(0.7, 0.2, 0.7);
            sourceMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xAAAAAA,
                metalness: 0.8,
                roughness: 0.2
            });
            break;
        default:
            // Generic source
            sourceGeometry = new THREE.BoxGeometry(0.6, 0.2, 0.6);
            sourceMaterial = new THREE.MeshPhongMaterial({ color: 0x555555 });
    }
    
    const source = new THREE.Mesh(sourceGeometry, sourceMaterial);
    source.position.y = -0.15;
    source.castShadow = true;
    source.receiveShadow = true;
    group.add(source);
}

// Start fire effects
function startFireEffects(fireType) {
    const fireModel = fireModels[fireType];
    if (!fireModel) return;
    
    // Clear existing particles
    clearFireParticles(fireModel);
    
    // Fire color based on type
    let fireColor;
    switch (fireType) {
        case 'electrical': fireColor = 0x66ccff; break; // Blue electrical fire
        case 'gas': fireColor = 0xff9900; break;        // Orange gas fire
        case 'wood': fireColor = 0xff3300; break;       // Red wood fire
        case 'liquid': fireColor = 0x9900ff; break;     // Purple liquid fire
        case 'metal': fireColor = 0xffffff; break;      // White metal fire
        default: fireColor = 0xff6600;                  // Default orange
    }
    
    // Create new fire particles
    createFireParticles(fireModel, fireColor);
    
    // Create smoke
    createSmokeParticles(fireModel);
    
    // Create embers (only for wood and certain fires)
    if (fireType === 'wood' || fireType === 'gas') {
        createEmberParticles(fireModel, fireColor);
    }
}

// Clear existing particles
function clearFireParticles(fireModel) {
    // Find particle containers
    fireModel.children.forEach(child => {
        if (child instanceof THREE.Group) {
            while (child.children.length > 0) {
                const particle = child.children[0];
                child.remove(particle);
                if (particle.geometry) particle.geometry.dispose();
                if (particle.material) particle.material.dispose();
            }
        }
    });
}

// Create fire particles
function createFireParticles(fireModel, color) {
    // Find fire particles container
    let fireParticles;
    fireModel.children.forEach(child => {
        if (child instanceof THREE.Group && !fireParticles) {
            fireParticles = child;
        }
    });
    
    if (!fireParticles) return;
    
    // Create multiple flames
    const particleCount = 15;
    
    for (let i = 0; i < particleCount; i++) {
        const size = Math.random() * 0.5 + 0.2;
        const flameGeometry = new THREE.ConeGeometry(size/2, size, 8);
        
        // Gradient color - yellow at bottom, fire color at top
        const flameMaterial = new THREE.MeshBasicMaterial({ 
            color: i % 3 === 0 ? 0xffff00 : color,
            transparent: true,
            opacity: 0.7 + Math.random() * 0.3
        });
        
        const flame = new THREE.Mesh(flameGeometry, flameMaterial);
        
        // Position randomly around center
        const angle = Math.random() * Math.PI * 2;
        const radius = Math.random() * 0.3;
        flame.position.x = Math.cos(angle) * radius;
        flame.position.z = Math.sin(angle) * radius;
        flame.position.y = 0.1 + Math.random() * 0.2;
        
        // Random rotation
        flame.rotation.y = Math.random() * Math.PI * 2;
        
        // Add to container
        fireParticles.add(flame);
        
        // Animate this flame
        animateFlame(flame);
    }
}

// Animate individual flame
function animateFlame(flame) {
    const originalY = flame.position.y;
    const originalScale = {x: flame.scale.x, y: flame.scale.y, z: flame.scale.z};
    const lifespan = 1000 + Math.random() * 1000; // 1-2 seconds
    const startTime = Date.now();
    
    function updateFlame() {
        const elapsed = Date.now() - startTime;
        const lifeRatio = elapsed / lifespan;
        
        if (lifeRatio < 1) {
            // Rise up
            flame.position.y = originalY + lifeRatio * 1.0;
            
            // Random flickering
            const flicker = Math.sin(elapsed * 0.01) * 0.1 + 0.9;
            flame.scale.x = originalScale.x * flicker;
            flame.scale.z = originalScale.z * flicker;
            
            // Fade out near the end
            if (lifeRatio > 0.7) {
                flame.material.opacity = 1 - ((lifeRatio - 0.7) / 0.3);
            }
            
            requestAnimationFrame(updateFlame);
        } else {
            // Reset for reuse
            flame.position.y = originalY;
            flame.scale.set(originalScale.x, originalScale.y, originalScale.z);
            flame.material.opacity = 0.7 + Math.random() * 0.3;
            
            // Start again
            setTimeout(() => {
                requestAnimationFrame(updateFlame);
            }, Math.random() * 200);
        }
    }
    
    updateFlame();
}

// Create smoke particles
function createSmokeParticles(fireModel) {
    // Find smoke particles container
    let smokeParticles;
    fireModel.children.forEach(child => {
        if (child instanceof THREE.Group && child !== fireModel.children[0]) {
            smokeParticles = child;
        }
    });
    
    if (!smokeParticles) return;
    
    // Create smoke particles
    const particleCount = 10;
    
    for (let i = 0; i < particleCount; i++) {
        const size = Math.random() * 0.4 + 0.2;
        const smokeGeometry = new THREE.SphereGeometry(size, 8, 8);
        const smokeMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x666666,
            transparent: true,
            opacity: 0.2 + Math.random() * 0.2
        });
        
        const smoke = new THREE.Mesh(smokeGeometry, smokeMaterial);
        
        // Position above fire
        const angle = Math.random() * Math.PI * 2;
        const radius = Math.random() * 0.3;
        smoke.position.x = Math.cos(angle) * radius;
        smoke.position.z = Math.sin(angle) * radius;
        smoke.position.y = 0.8 + Math.random() * 0.3;
        
        // Add to container
        smokeParticles.add(smoke);
        
        // Animate this smoke particle
        animateSmoke(smoke);
    }
}

// Animate individual smoke particle
function animateSmoke(smoke) {
    const originalY = smoke.position.y;
    const originalScale = {x: smoke.scale.x, y: smoke.scale.y, z: smoke.scale.z};
    const lifespan = 2000 + Math.random() * 1000; // 2-3 seconds
    const startTime = Date.now();
    
    function updateSmoke() {
        const elapsed = Date.now() - startTime;
        const lifeRatio = elapsed / lifespan;
        
        if (lifeRatio < 1) {
            // Rise up and drift
            smoke.position.y = originalY + lifeRatio * 2.0;
            smoke.position.x += Math.sin(elapsed * 0.001) * 0.01;
            smoke.position.z += Math.cos(elapsed * 0.001) * 0.01;
            
            // Expand
            const expansion = 1 + lifeRatio * 1.5;
            smoke.scale.set(
                originalScale.x * expansion,
                originalScale.y * expansion,
                originalScale.z * expansion
            );
            
            // Fade out
            smoke.material.opacity = 0.3 * (1 - lifeRatio);
            
            requestAnimationFrame(updateSmoke);
        } else {
            // Reset for reuse
            smoke.position.y = originalY;
            smoke.scale.set(originalScale.x, originalScale.y, originalScale.z);
            smoke.material.opacity = 0.2 + Math.random() * 0.2;
            
            // Start again
            setTimeout(() => {
                requestAnimationFrame(updateSmoke);
            }, Math.random() * 500);
        }
    }
    
    updateSmoke();
}

// Create ember particles (for wood fires)
function createEmberParticles(fireModel, color) {
    // Find ember particles container
    let emberParticles;
    fireModel.children.forEach(child => {
        if (child instanceof THREE.Group && child !== fireModel.children[0] && child !== fireModel.children[1]) {
            emberParticles = child;
        }
    });
    
    if (!emberParticles) return;
    
    // Create embers
    const particleCount = 5;
    
    for (let i = 0; i < particleCount; i++) {
        const size = Math.random() * 0.05 + 0.02;
        const emberGeometry = new THREE.SphereGeometry(size, 4, 4);
        const emberMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xff3300,
            emissive: 0xff0000,
            emissiveIntensity: 1
        });
        
        const ember = new THREE.Mesh(emberGeometry, emberMaterial);
        
        // Position at base of fire
        ember.position.y = 0.1;
        
        // Add to container
        emberParticles.add(ember);
        
        // Animate this ember
        animateEmber(ember);
    }
}

// Animate individual ember
function animateEmber(ember) {
    const lifespan = 1500 + Math.random() * 1000; // 1.5-2.5 seconds
    const startTime = Date.now();
    
    // Random trajectory
    const velocityX = (Math.random() - 0.5) * 0.01;
    const velocityY = 0.01 + Math.random() * 0.02;
    const velocityZ = (Math.random() - 0.5) * 0.01;
    
    function updateEmber() {
        const elapsed = Date.now() - startTime;
        const lifeRatio = elapsed / lifespan;
        
        if (lifeRatio < 1) {
            // Move ember
            ember.position.x += velocityX;
            ember.position.y += velocityY;
            ember.position.z += velocityZ;
            
            // Gravity effect - slow down vertical velocity
            const gravityEffect = 0.0003;
            velocityY.y -= gravityEffect;
            
            // Fade out near the end
            if (lifeRatio > 0.7) {
                ember.material.opacity = 1 - ((lifeRatio - 0.7) / 0.3);
            }
            
            requestAnimationFrame(updateEmber);
        } else {
            // Reset for reuse
            ember.position.set(0, 0.1, 0);
            ember.material.opacity = 1.0;
            
            // Start again after delay
            setTimeout(() => {
                requestAnimationFrame(updateEmber);
            }, Math.random() * 1000);
        }
    }
    
    updateEmber();
}

// Create ember particle
function createEmber(group, color) {
    const size = Math.random() * 0.03 + 0.01;
    const geometry = new THREE.SphereGeometry(size);
    const material = new THREE.MeshBasicMaterial({ 
        color: new THREE.Color(color).lerp(new THREE.Color(0xffff80), 0.5),
        transparent: true,
        opacity: 0.7
    });
    
    const ember = new THREE.Mesh(geometry, material);
    
    // Initial position
    const angle = Math.random() * Math.PI * 2;
    const radius = Math.random() * 0.3;
    ember.position.set(
        Math.cos(angle) * radius,
        Math.random() * 0.1,
        Math.sin(angle) * radius
    );
    
    group.add(ember);
    
    // Animate ember
    animateEmber(ember);
}

// Animate ember particle
function animateEmber(ember) {
    const startY = ember.position.y;
    const speed = Math.random() * 0.02 + 0.01;
    const maxHeight = Math.random() * 2 + 1;
    
    function update() {
        if (!ember.parent) return;
        
        ember.position.y += speed;
        ember.position.x += (Math.random() - 0.5) * 0.01;
        ember.position.z += (Math.random() - 0.5) * 0.01;
        
        // Fade out as it rises
        ember.material.opacity = Math.max(0, 1 - (ember.position.y / maxHeight));
        
        if (ember.position.y < startY + maxHeight) {
            requestAnimationFrame(update);
        } else {
            // Reset ember for reuse
            const angle = Math.random() * Math.PI * 2;
            const radius = Math.random() * 0.3;
            ember.position.set(
                Math.cos(angle) * radius,
                Math.random() * 0.1,
                Math.sin(angle) * radius
            );
            ember.material.opacity = 0.7;
            animateEmber(ember);
        }
    }
    
    update();
}

// Create smoke particle
function createSmoke(group) {
    const size = Math.random() * 0.2 + 0.2;
    const geometry = new THREE.PlaneGeometry(size, size);
    const material = new THREE.MeshBasicMaterial({ 
        color: 0x666666,
        transparent: true,
        opacity: Math.random() * 0.2 + 0.05
    });
    
    const smoke = new THREE.Mesh(geometry, material);
    smoke.rotation.z = Math.random() * Math.PI;
    
    // Initial position
    const angle = Math.random() * Math.PI * 2;
    const radius = Math.random() * 0.3;
    smoke.position.set(
        Math.cos(angle) * radius,
        Math.random() * 0.5 + 0.5,
        Math.sin(angle) * radius
    );
    
    group.add(smoke);
    
    // Animate smoke
    animateSmoke(smoke);
}

// Animate smoke particle
function animateSmoke(smoke) {
    const startY = smoke.position.y;
    const speed = Math.random() * 0.01 + 0.005;
    const maxHeight = Math.random() * 2 + 2;
    
    function update() {
        if (!smoke.parent) return;
        
        smoke.position.y += speed;
        smoke.position.x += (Math.random() - 0.5) * 0.005;
        smoke.position.z += (Math.random() - 0.5) * 0.005;
        smoke.rotation.z += Math.random() * 0.01;
        
        // Fade out as it rises
        smoke.material.opacity = Math.max(0, smoke.material.opacity - 0.001);
        
        // Increase size slightly
        smoke.scale.x += 0.001;
        smoke.scale.y += 0.001;
        
        if (smoke.position.y < startY + maxHeight && smoke.material.opacity > 0) {
            requestAnimationFrame(update);
        } else {
            // Reset smoke for reuse
            const angle = Math.random() * Math.PI * 2;
            const radius = Math.random() * 0.3;
            smoke.position.set(
                Math.cos(angle) * radius,
                Math.random() * 0.5 + 0.5,
                Math.sin(angle) * radius
            );
            smoke.scale.set(1, 1, 1);
            smoke.material.opacity = Math.random() * 0.2 + 0.05;
            animateSmoke(smoke);
        }
    }
    
    update();
}
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Update animation mixer if exists
            if (mixer) {
                mixer.update(clock.getDelta());
            }
            
            renderer.render(scene, camera);
        }
        
        // Initialize game
        // Initialize game
function initGame() {
    // Reset game state
    currentLevel = 1;
    score = 0;
    lives = 3;
    gameActive = true;
    selectedExtinguisher = null;
    
    // Update UI
    updateLevel();
    updateScore();
    updateLives();
    
    // Hide use button
    useExtinguisherBtn.style.display = 'none';
    
    // Detect ground first, then spawn fire
    if (detectGround()) {
        spawnFire();
    } else {
        // If no ground detected yet, wait and try again
        setTimeout(() => {
            detectGround();
            spawnFire();
        }, 1000);
    }
}
        
        // Start camera
        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: 'environment' } 
                });
                cameraView.srcObject = stream;
            } catch (err) {
                console.error("Error accessing camera: ", err);
                // Fallback to a solid background if camera access fails
                cameraView.style.display = 'none';
                gameContainer.style.backgroundColor = '#333';
            }
        }
        
        // Update level display
        function updateLevel() {
            levelIndicator.textContent = `Level: ${currentLevel}`;
        }
        
        // Update score display
        function updateScore() {
            scoreIndicator.textContent = `Score: ${score}`;
        }
        
        // Update lives display
        function updateLives() {
            livesContainer.innerHTML = '';
            for (let i = 0; i < lives; i++) {
                const lifeIcon = document.createElement('div');
                lifeIcon.className = 'life-icon';
                livesContainer.appendChild(lifeIcon);
            }
        }
        
        // Spawn a new fire
function spawnFire() {
    if (!gameActive) return;
    
    // Hide all fire models
    Object.values(fireModels).forEach(model => {
        model.visible = false;
    });
    
    // Hide extinguisher model
    if (extinguisherModel) {
        extinguisherModel.visible = false;
    }
    
    // Pick a random fire type, but weight towards different fires in higher levels
    let availableFires = fireTypes;
    if (currentLevel <= 2) {
        // Only basic fires in early levels
        availableFires = fireTypes.slice(0, 3);
    }
    
    // Select random fire type
    const randomIndex = Math.floor(Math.random() * availableFires.length);
    activeFire = availableFires[randomIndex];
    
    // Position the 3D fire model on detected ground
    const fireModel = fireModels[activeFire.type];
    
    if (groundDetected) {
        // Place fire at detected ground position
        fireModel.position.copy(groundPosition);
        fireModel.visible = true;
        
        // Scale based on level (smaller fires at higher levels)
        const scale = Math.max(0.6, 1 - (currentLevel * 0.05));
        fireModel.scale.set(scale, scale, scale);
        
        // Start fire animations
        startFireEffects(activeFire.type);
    } else {
        // If no ground detected, try again after a delay
        setTimeout(spawnFire, 1000);
    }
}
        
        // Handle extinguisher selection
        function handleExtinguisherSelection(e) {
            if (!gameActive || !activeFire) return;
            
            const extinguisherType = e.currentTarget.getAttribute('data-type');
            selectedExtinguisher = extinguisherType;
            
            // Show the 3D extinguisher model
            extinguisherModel.visible = true;
            
            // Position extinguisher at bottom of screen pointing at fire
            extinguisherModel.position.x = -1;
            extinguisherModel.position.y = -2;
            extinguisherModel.position.z = 1;
            
            // Rotate to point at fire
            extinguisherModel.lookAt(fireModels[activeFire.type].position);
            
            // Color the extinguisher based on type
            extinguisherModel.children.forEach(child => {
                if (child.material) {
                    // Keep handle and nozzle metallic
                    if (child === extinguisherModel.children[0]) { // Tank
                        child.material.color.setHex(extinguisherColors[extinguisherType]);
                    }
                }
            });
            
            // Show use button
            useExtinguisherBtn.style.display = 'block';
        }
        
        // Handle use extinguisher button click
        function handleUseExtinguisher() {
            if (!gameActive || !activeFire || !selectedExtinguisher) return;
            
            // Create spray effect
            const spray = createSprayEffect(extinguisherColors[selectedExtinguisher]);
            spray.position.copy(extinguisherModel.position);
            spray.rotation.copy(extinguisherModel.rotation);
            scene.add(spray);
            
            // Hide button during animation
            useExtinguisherBtn.style.display = 'none';
            
            // Remove spray after animation
            setTimeout(() => {
                scene.remove(spray);
                
                // Check if correct extinguisher was used
                if (selectedExtinguisher === activeFire.correctExtinguisher) {
                    // Correct extinguisher
                    handleCorrectExtinguisher();
                } else {
                    // Wrong extinguisher
                    handleWrongExtinguisher();
                }
            }, 2000);
        }
        
        // Handle correct extinguisher
        function handleCorrectExtinguisher() {
            // Add score based on level
            score += currentLevel * 10;
            updateScore();
            
            // Show positive feedback
            const randomFeedback = positiveFeedback[Math.floor(Math.random() * positiveFeedback.length)];
            showFeedback(randomFeedback, '#4CAF50');
            
            // Fade out fire (scale down and fade)
            const fireModel = fireModels[activeFire.type];
            animateFireOut(fireModel);
            
            // Hide extinguisher
            extinguisherModel.visible = false;
            
            // Reset selected extinguisher
            selectedExtinguisher = null;
            
            // Advance to next level after every 3 correct fires
            if (score >= currentLevel * 30) {
                currentLevel++;
                updateLevel();
            }
            
            // Spawn next fire after delay
            setTimeout(() => {
                spawnFire();
            }, 2000);
        }
        
        // Animate fire extinguishing
        function animateFireOut(fireModel) {
            let scale = 1.0;
            let opacity = 1.0;
            
            function shrink() {
                scale -= 0.05;
                opacity -= 0.05;
                
                fireModel.scale.set(scale, scale, scale);
                
                // Update opacity of all materials
                fireModel.traverse(child => {
                    if (child.material) {
                        child.material.opacity = opacity;
                    }
                });
                
                if (scale > 0.1) {
                    requestAnimationFrame(shrink);
                } else {
                    fireModel.visible = false;
                    // Reset scale and opacity for next use
                    fireModel.scale.set(1, 1, 1);
                    fireModel.traverse(child => {
                        if (child.material) {
                            child.material.opacity = 1;
                        }
                    });
                }
            }
            
            shrink();
        }
        
        // Handle wrong extinguisher
        function handleWrongExtinguisher() {
            // Show negative feedback
            const randomFeedback = negativeFeedback[Math.floor(Math.random() * negativeFeedback.length)];
            showFeedback(randomFeedback, '#F44336');
            
            // Lose a life
            lives--;
            updateLives();
            
            // Hide extinguisher
            extinguisherModel.visible = false;
            
            // Reset selected extinguisher
            selectedExtinguisher = null;
            
            if (lives <= 0) {
                endGame();
            }
        }
        
        // Show feedback message
        function showFeedback(message, color) {
            feedback.textContent = message;
            feedback.style.backgroundColor = color;
            feedback.style.opacity = '1';
            
            setTimeout(() => {
                feedback.style.opacity = '0';
            }, 1500);
        }
        
        // End game
        function endGame() {
            gameActive = false;
            
            // Hide all 3D models
            Object.values(fireModels).forEach(model => {
                model.visible = false;
            });
            
            if (extinguisherModel) {
                extinguisherModel.visible = false;
            }
            
            // Hide use button
            useExtinguisherBtn.style.display = 'none';
            
            // Show game over screen
            finalScore.textContent = `Score: ${score}`;
            gameOverScreen.style.display = 'flex';
        }
        
        // Restart game
        function restartGame() {
            // Hide game over screen
            gameOverScreen.style.display = 'none';
            
            // Initialize new game
            initGame();
        }
        
        // Event listeners
        startButton.addEventListener('click', () => {
            startScreen.style.display = 'none';
            initGame();
        });
        
        restartButton.addEventListener('click', restartGame);
        
        infoButton.addEventListener('click', () => {
            infoPanel.style.display = 'block';
        });
        
        closeInfoButton.addEventListener('click', () => {
            infoPanel.style.display = 'none';
        });
        
        // Extinguisher selection event listeners
        document.querySelectorAll('.extinguisher-btn').forEach(btn => {
            btn.addEventListener('click', handleExtinguisherSelection);
        });
        
        useExtinguisherBtn.addEventListener('click', handleUseExtinguisher);
        
        // Initialize the application
        function init() {
            // Start camera
            startCamera();
            
            // Initialize 3D scene
            initThreeJS();
            
            // Load 3D models
            loadModels();
            
            // Show start screen (game will start when user clicks button)
        }
        
        // Start the app when loaded
        window.addEventListener('load', init);
    </script>
</body>
</html>